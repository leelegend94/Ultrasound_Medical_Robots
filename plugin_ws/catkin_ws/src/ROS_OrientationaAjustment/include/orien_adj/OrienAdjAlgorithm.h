#pragma once

#include <ImFusion/Base/Algorithm.h>
#include <ImFusion/Base/DataModel.h>
#include <ImFusion/Stream/OpenIGTLinkTrackingStream.h>

#include <iiwa_ros/state/cartesian_pose.hpp>
#include <iiwa_ros/state/cartesian_wrench.hpp>
#include <iiwa_ros/state/joint_torque.hpp>

#include <iiwa_ros/command/cartesian_pose.hpp>
#include <iiwa_ros/command/cartesian_pose_linear.hpp>

#include <iiwa_ros/service/control_mode.hpp>

#include <iiwa_msgs/DOF.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/WrenchStamped.h>

#include <Eigen/Dense>
#include <QObject>
#include <string>
#include <vector>
#include <QVector>

#include <iostream>


const int ON_CURRENT_POSE = -1;
const int ON_INITIAL_POSE = 0;
const int ON_FINAL_POSE = 1;
const int ON_BACK_INITIAL_POSE = 2;

const int FAN_MOTION_STYPE_CONTINOUS = 0;
const int FAN_MOTION_STYPE_STEP = 1;

const int ROTATION_X = 0;
const int ROTATION_Y = 1;

namespace ImFusion {
namespace OrienAdj {

class PluginAlgorithm : public QObject, public ImFusion::Algorithm {
  Q_OBJECT
public:
  PluginAlgorithm();
  ~PluginAlgorithm();



  void compute();

  void doSomething();

  //! Methods implementing the Configurable interface.
  void configure(const Properties* p);
  void configuration(Properties* p) const;

  //JZL
  /**
   * @brief Connect to the robot.
   * @param [in] probe_name - the name of the ultrasound probe being used. The respective calibration will be loaded
   * from from IFLUSCalibration file.
   */
  void connect(const std::string& probe_name);
  void disconnect();
  inline bool isRobotConnected() { return is_robot_connected_; }

  /**
   * @brief Add the tracking stream generated by thi algorithm to the provided DataModel.
   * @param [in] data_model
   */
  void addStreamToDataModel(DataModel* data_model) {
    data_model->add(tracking_stream_, "Robot Tracking");
    owning_stream_ = false;
  }

  static bool createCompatible(const DataList& data, Algorithm** a = nullptr);

  //JZL
  /// Motions.
  /**
   * @brief Make the robot execute a Cartesian motion to the given target pose.
   * @param [in] pose - Target pose for the motion.
   * @param [in] linear - If true, a linear motion will be executed.
   * @param [in] callback - Optional callback function to be called when the robot reaches the given target pose.
   */
  void executeCartesianCommand(const geometry_msgs::Pose& pose, bool linear,
                               const std::function<void()>& callback = nullptr);

  /**
   * @brief Make the robot execute a Cartesian motion to the given target pose.
   * @param [in] matrix - Target pose for the motion.
   * @param [in] linear - If true, a linear motion will be executed.
   * @param [in] callback - Optional callback function to be called when the robot reaches the given target pose.
   */
  void executeCartesianCommand(const Eigen::Matrix4d& matrix, bool linear,
                               const std::function<void()>& callback = nullptr);

  /**
   * @brief Make the robot execute a Cartesian motion to the given target pose.
   * @param [in] q - Rotation component of the target pose for the robot motion.
   * @param [in] t - Translational component of the target pose for the robot motion.
   * @param [in] linear - If true, a linear motion will be executed.
   * @param [in] callback - Optional callback function to be called when the robot reaches the given target pose.
   */
  void executeCartesianCommand(const Eigen::Quaterniond& q, const Eigen::Vector3d& t, bool linear,
                               std::function<void()> callback = nullptr);

  /**
   * @brief Activate position mode on the robot.
   */
  void applyPositionControlMode() {
    control_mode_.setPositionControlMode();
  }

  /**
   * @brief Activate DesiredForce mode on the robot with the given values.
   * @param [in] dof - The Degee of Freedong the force should be applied to.
   * @param [in] force - The force to be applied [N]
   * @param [in] stiffness - the Cartesian stiffness to apply on the given direction.
   */
  void applyDesiredForce(int dof, double force, double stiffness) {
    control_mode_.setDesiredForceMode(dof, force, stiffness);
  }

  /**
   * @brief Save the given robot pose as the 'Home' Pose.
   * @param [in] pose - the pose to become the new 'Home' pose.
   */
  void setRobotHomeConfiguration(const geometry_msgs::PoseStamped& pose) { home_pose_ = pose; }

  /**
   * @brief Returns the saved "Home" pose for the robot.
   */
  geometry_msgs::PoseStamped getRobotHomeConfiguration() { return home_pose_; }

  /**
   * @brief Save the given robot pose as the 'OutOfWorkspace' Pose.
   * @param [in] pose - the pose to become the new 'OutOfWorkspace' pose.
   */
  void setRobotOutConfiguration(const geometry_msgs::PoseStamped& pose) { out_pose_ = pose; }

  /**
   * @brief Returns the saved "OutOfWorkspace" pose for the robot.
   */
  geometry_msgs::PoseStamped getRobotOutConfiguration() { return out_pose_; }

  /**
   * @brief Returns the ultrasound temporal calibration.
   * It is loaded from the configuration file.
   */
  inline float getTemporalCalibration() { return temporal_calibration_; }

  /**
   * @brief Returns the latest Cartesian pose of the robot tool tip.
   *
   * The tool tip is selected according to the tool loaded using the ROS parameter.
   */
  geometry_msgs::PoseStamped getCurrentRobotPose();

  /**
   * @brief Returns the latest Cartesian pose f the robot tool tip as an homogeneous matrix.
   *
   * The tool tip is selected according to the tool loaded using the ROS parameter.
   *
   * @param [in] in_millimeters - If true, the translation elements of the returned matrix will be in millimters.
   */
  Eigen::Matrix4d getCurrentRobotTransformMatrix(bool in_millimeters = false);

  /**
   * @brief Returns the latest Cartesian pose f the robot tool tip as an homogeneous matrix.
   *
   * The tool tip is selected according to the tool loaded using the ROS parameter.
   *
   * @param [in] in_millimeters - If true, the translation elements of the returned matrix will be in millimters.
   */
  geometry_msgs::Wrench getCurrentRobotWrench();

  /**
   * @brief Returns the latest Cartesian pose of the image center.
   *
   * This is computed according to the calibration file that has been loaded upon connection.
   * See loadCalibrationFromFile.
   */
  geometry_msgs::PoseStamped getCurrentImageCenterPose();


  /**
   * @brief Load the Ultrasound calibration from the given file_name looking for the calibration of the given probe
   * name.
   * @param [in] file_name - The config file to load the calibration from. The folder containing this file is defined by
   * the CMake variable CONFIG_DIR, in the main CMake file of this plugin.
   * @param [in] probe - Name of the probe to load the calibration of. If this probe name is not found in the provided
   * calibration file, the ultrasound calibration will be omitted.
   */
  void loadCalibrationFromFile(const std::string& file_name, const std::string& probe);


  ////////////////////OrienAdj Tasks
  /**
   * @brief robot would keep in current  position and change the orientation like fan
   * @param [in] vecAxis - rotate around axis
   * @param [in] currentPose - current pose of robot
   * @param [in] dUpLimitedAngle (unit is degree) - the up limited angle relative to current angle (about special axis)
   * @param [in] dDownLimitedAngle (unit is degree) - the up limited angle relative to current angle (about special axis)
   */
  void fanShapMotion(double dUpLimitedAngle, double dStepAngle, int nRoationAxis, int nFanMotionType = FAN_MOTION_STYPE_CONTINOUS);

  /**
   * @brief robot would keep in current  position and change the orientation like fan
   * @param [in] vecAxis - rotate around this axis
   * @param [in] dRotationRadius (unit is mm) - the up limited angle relative to current angle (about special axis)
   * @param [in] dHeight (unit is mm) - the radius is mearsured in sepcialed height
   */
  void coneShapMotion(Eigen::Vector3d vecAxis, double dRotationRadius, double dHeight);

  //continuous mode and step by step mode
  void calculateEndPoints(double fOffsetAngle, int nRotationAxis = ROTATION_X);   //unit is degree
  void calculateEndPointsTCP(double fOffsetAngle, int nRotationAxis = ROTATION_X);   //around TCP
  void calculateEndPointsStep(double fOffsetAngle, double dStep = 2.0, int nRotationAxis = ROTATION_X);   //unit is degree
  void calculateEndPointsStepTCP(double fOffsetAngle, double dStep = 2.0, int nRotationAxis = ROTATION_X);   //around TCP

  void RotateAroundTCP(double fOffsetAngle, int nRotationAxis);

  Eigen::Vector3d calculateReleativeRatationAngle(Eigen::Matrix3d& initialFrame, Eigen::Matrix3d& currentFrame);  //used to calculate eular angle relate to pose base

  void onGotoPose(const  Eigen::Matrix4d& pose, bool callback = true);
  void onStepGotoPose(const  Eigen::Matrix4d& pose, bool callback = true);

  int onGetStepFanMotionIteration();
  void stopStepFanMotion();


  //used for saving the two end poins
  Eigen::Matrix4d m_initialPose{Eigen::Matrix4d::Identity()};
  Eigen::Matrix4d m_finalPose{Eigen::Matrix4d::Identity()};
  QVector <Eigen::Matrix4d> m_vecPose;
  Eigen::Matrix4d m_rotationMatrix{Eigen::Matrix4d::Identity()};

  Eigen::Matrix4d m_initialFrameFan{Eigen::Matrix4d::Identity()};   //pose when we start fan searching


signals:
  void somethingHappened();

  //JZL
  void poseChanged();
  void wrenchChanged();
  void robotConnected();
  void robotDisconnected();

private:
  //JZL
  void poseCallback(const iiwa_msgs::CartesianPose &pose);
  void wrenchCallback(const iiwa_msgs::CartesianWrench& wench);
  //JZL_from roboticSpineAlgorithmController
  void movementFinishCallback();
  void stepMovementFinishCallback();



  geometry_msgs::Pose eigenMat4ToPose(Eigen::Matrix4d matrix, double scaling_factor = 1);
  Eigen::Matrix4d poseToEigenMat4(const geometry_msgs::Pose& pose, double scaling_factor = 1);

  iiwa_ros::state::CartesianPose pose_state_{};
  iiwa_ros::state::CartesianWrench wrench_state_{};
  iiwa_ros::state::JointTorque torque_state_{};

  iiwa_ros::command::CartesianPose pose_command_{};
  iiwa_ros::command::CartesianPoseLinear linear_pose_command_{};
  iiwa_ros::service::ControlModeService control_mode_{};

  std::unique_ptr<ros::AsyncSpinner> ros_spinner_{nullptr};
  OpenIGTLinkTrackingStream* tracking_stream_{nullptr};
  bool owning_stream_{true};
  bool is_robot_connected_{false};

  std::string configuration_dir{CONFIG_DIR};
  Eigen::Matrix4d probe_rotation_{Eigen::Matrix4d::Identity()};
  Eigen::Matrix4d ultrasound_calibration_{Eigen::Matrix4d::Identity()};
  float temporal_calibration_{0};
  //"IFLConvex"

  //! The current pose of the robot tip, according to the used tool defined in ROS.
  geometry_msgs::PoseStamped current_tip_pose_{};
  //! The current pose of the robot tip, according to the used tool defined in ROS.
  geometry_msgs::Wrench current_tip_wrench_{};
  //! The current pose of the center of the image, according to the loaded tool from the calibration file.
  geometry_msgs::PoseStamped current_image_center_pose_{};

  geometry_msgs::PoseStamped home_pose_{};
  geometry_msgs::PoseStamped out_pose_{};

  std::mutex pose_mutex_{};
  std::mutex wrench_mutex_{};


  std::string something_{"something"};

  int m_fanStatus{-1};
  int m_nIteration{0};   //used in stepCallback



};
}  // namespace OrienAdj
}  // namespace ImFusion
